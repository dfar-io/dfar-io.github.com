---
title: The Benefits of Test-driven Development
author: dfar

date: 2018-10-28T21:12:54+00:00
excerpt: |
  
  <![CDATA[]]>
url: /the-benefits-of-test-driven-development/
categories:
  - Uncategorized

---
 <p><em>This post was originally featured at <a href="https://devops.com/the-benefits-of-test-driven-development/">DevOps.com</a>.</em></p> <p><br/>It sounds like an oxymoron: Create test cases before coding. In the process of writing and using test cases before writing functionality, a developer can produce higher-quality software. That is the concept behind test-driven development (TDD), and it works.</p> <h2>TDD Snapshot</h2> <p> TDD has been around since at least 1999, and it is part of the emerging test-first approach to development associated with extreme programming. In 2003, American software developer Kent Beck “rediscovered” TDD and applied it as a way to create simple designs and inspire developer confidence. Fast forward to today’s agile development world, TDD is a software development process using a very short feedback loop in which developers do the following: </p> <ol><li>Create a test that will fail immediately.</li><li>Write the necessary code to pass the test as quickly as possible.</li><li>Refactor the code written in step two, using the created test as a reference. </li></ol> <h2>TDD Benefits</h2> <p>So why might a long-in-the-tooth software development approach have tangible benefits in an agile development world? Because put in its simplest terms, TDD is a way to develop highly usable software.</p> <p>Following the TDD process, a developer must focus on the test cases before actually coding anything. That means a developer is thinking more about the use of the software and the design of user interfaces to achieve that. As a result, the developer is more interested in the interface than in the implementation—and that leads to more usable software.</p> <p>There are several other tangible benefits for taking a TDD approach, including:</p> <ul><li>Creating a metric for the code quality that can be easy and quick.</li><li>Allowing for a quick visualization to determine if the code base has any functional issues.</li><li>Living documentation of functionality with new code written.</li><li>Allowing for safe refactors of code, whether based on attempts to improve code quality or a changed requirement.</li></ul> <p>That final point is worth dwelling on for a moment. The TDD approach requires that the evolving code base is cleaned up frequently so that new tests and code are easy to introduce. That usually means that code moves from its current place to where it more logically belongs in the software. That has the effect of reducing any extraneous duplication of code and enforces a strong discipline around objects, classes, modules, etc. In this way, the overall maintainability of the software increases incrementally.</p> <p>The improvement in readability and maintainability will pay huge dividends during the expected life cycle of the software. Following a TDD methodology requires developers to focus on writing smaller units of testable code. By following the TDD methodology, this leads to more modularized, flexible and extensible software.</p> <h2>Where Can TDD Fit?</h2> <p>A TDD approach is appropriate for both new greenfield software and legacy systems. For a development team that has to deal with existing legacy software, the key is to start small and begin with working on bug fixes. A good practice is that for each bug reported, create a test that addresses the broken bug and then fix the functionality. After several iterations of this, the development team has created a repeatable working test to address bug fixes. When applying this methodology to new software applications, make a point of understanding the testing tools used for the technology stack.</p> <p>For example, when working in an Angular application that generally uses the <a href="https://jasmine.github.io/">Jasmine testing framework</a> for unit testing, and when using the Angular CLI for creation, unit tests are created alongside modules of code. Using a TDD methodology, the approach would be to:</p> <ol><li>Determine a portion of the functionality to be created with this component.</li><li>Create a unit test that will fail immediately targeting this portion of functionality.</li><li>Run the test runner to confirm the failing test (it may be useful here to leave the test runner on to run after each source file save, which speeds the process).</li><li>Write code in the Angular component that will make the written test pass.</li><li>Make any refactoring changes for the Angular component after confirming passing, using the test as a guideline to ensure code refactoring does not break functionality.</li></ol> <h2>Measuring Testability with Code Coverage</h2> <p>Another essential consideration when improving testability in code is to use a code coverage tool. Code coverage is a metric to show the percentage of code that has a unit test written for it. Angular applications use <a href="https://github.com/istanbuljs">Istanbul</a> to calculate code coverage through the application. Running a single run of code coverage in an existing project gives the following output:</p> <div class="wp-block-image"><figure class="aligncenter"><img src="https://3ovyg21t17l11k49tk1oma21-wpengine.netdna-ssl.com/wp-content/uploads/2018/10/code\_coverage\_output_v2.jpeg" alt="" class="wp-image-126009"/></figure></div> <p>The output provided by Istanbul gives a metric on the overall test coverage and the areas of code that need improvement in testing. Code coverage can be useful in a few ways:</p> <ul><li>Provides an idea of the overall testability, allowing for a threshold to ensure the total software testability does not drop past a certain point.</li><li>Identifies areas in the code base with poor testing, making them opportunities for refactoring.</li></ul> <p>However, as effective as code coverage can sound, it’s important to understand that it’s just a metric. Writing good unit tests is a matter of following what the code will do, and metrics such as these should not drive significant decisions.</p> <h2>Considerations When Using TDD</h2> <p>It’s important to note that TDD does not solve all problems. There are many different types of testing required to create a fully comprehensive testing strategy, including acceptance testing. In TDD, the focus is on a single unit of code at a time. A sophisticated software application may have many thousands of units of code and their corresponding tests. That’s why it’s critical to make sure that testing quality stays high when following the TDD methodology. Tests cannot become something bypassed in the pursuit of more functionality or expediency. Avoiding testing generates the risk of test creation becoming a hindrance for developers.</p> <p>For example, ignoring failing tests makes it difficult to determine the actual state of the application. It’s also important to have buy-in for a TDD approach form all the teams involved in the effort. Buy-in is particularly true on the business side. Time must be spent up front discussing the nature and benefits of a TDD approach, and the belief that using TDD will improve the resulting software. Otherwise, business management sees writing tests as an activity that doesn’t contribute to the bottom line.</p> <h2>Conclusion</h2> <p> TDD emphasizes the importance of an effective and sustainable testing approach. TDD also contributes directly to the overall quality of software. It’s a truism for small or large system development that often goes missing in the day-to-day hustle to get new functionality into production. Quality software gets built when there’s an acknowledgment that quality test code should receive the same amount of attention and resources as quality production code, as they are equally essential in development. </p>