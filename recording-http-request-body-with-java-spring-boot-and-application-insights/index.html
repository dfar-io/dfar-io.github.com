<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Software/DevOps Engineer">
<link rel="shortcut icon" href=https://dfar.io/favicon.ico>
<link rel=stylesheet href=/css/style.min.css>
<title>Recording HTTP Request Body with Java, Spring Boot and Application Insights</title>
</head>
<body><header id=banner>
<h2><a href=https://dfar.io/>Dave Farinelli</a></h2>
<nav>
<ul>
<li>
<a href=/about/ title=about>about</a>
</li>
</ul>
</nav>
</header>
<main id=content>
<article>
<header id=post-header>
<h1>Recording HTTP Request Body with Java, Spring Boot and Application Insights</h1><time>April 23, 2020</time></header><p>Building off of my previous post <a href=https://dfar.io/integrate-application-insights-into-a-spring-boot-application/>about integrating App Insights into Spring Boot</a>, I also wanted to record the request body in each trace sent to Azure. This is especially useful when looking up failures, since you’ll be able to see the request body used that caused the failure.</p>
<h2 id=important-note-regarding-privacy>Important Note Regarding Privacy</h2>
<p>Before getting started, something to consider is the issue of privacy – by activating this, you’ll be storing request body information into Azure, which can be an issue if you’re dealing with sensitive information.</p>
<p>If that’s the case, you should be sure to process the body extracted from this inplementation and remove the sensitive information in the payload before adding it to the request telemetry.</p>
<h2 id=bypassing-the-httpservletrequest-issue>Bypassing the HttpServletRequest issue</h2>
<p>Java servlets do not allow the ability to read a response multiple times – if you try to do so by reading <code>getReader()</code> multiple times, you’ll get an IllegalStateException. To fix this, we’ll create a custom implementation of HttpServletRequest that will cache the request provided, allowing us to read the request body, and then passing this down further the Spring Boot chain.</p>
<p>Create the <code>CachedBodyHttpServletRequest</code> class:</p>
<p>Next, create the <code>CachedBodyServletInputStream</code> class:</p>
<h2 id=adding-cachedbodyhttpservletrequest-to-spring-boot-filter>Adding CachedBodyHttpServletRequest to Spring Boot Filter</h2>
<p>To use this, you’ll create a filter that activates before processing a request, which will add the request body to the request telemetry when defined as a POST or PUT method.</p>
<p>Create the <code>CachedHttpServletRequestFilter</code> class:</p>
<h2 id=verification>Verification</h2>
<p>To verify, start running the application and make a few calls. When observing the requests in App Insights, you should be able to see the recorded Request Body on all POST and PUT calls:</p>
<p> </p>
</article>
</main><footer id=footer>
</footer>
</body>
</html>