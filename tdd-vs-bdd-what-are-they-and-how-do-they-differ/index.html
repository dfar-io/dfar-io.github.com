<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Software/DevOps Engineer"><link rel="shortcut icon" href=https://dfar.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>TDD vs. BDD: What Are They and How Do They Differ?</title></head><body><header id=banner><h2><a href=https://dfar.io/>Dave Farinelli</a></h2><nav><ul><li><a href=/about/ title=about>about</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>TDD vs. BDD: What Are They and How Do They Differ?</h1><time>September 30, 2018</time></header><p>Improving the testability of software is extremely important, and a difficult ideal in its own right. To achieve that, engineers and others interested in software testability have created many strategies, tools, and methodologies to improve the testability of software solutions.</p><p>With so many methodologies and techniques available, which one should you choose? Two of the most prominent methodologies I’ve encountered are <a href=https://blog.ncrunch.net/post/test-driven-development-first-principles-explanation.aspx>test-driven development</a> (TDD) and <a href=https://en.wikipedia.org/wiki/Behavior-driven_development>behavior-driven development</a> (BDD). In this post, I’ll describe what TDD and BDD are, discuss their real-world applications, and explain how they differ. In addition, I’ll talk about considerations between TDD vs. BDD.</p><p>Here are some facts to consider when thinking about TDD vs. BDD.</p><p><img src="https://blog.ncrunch.net/image.axd?picture=2018%2f9%2fTDD_vs_BDD_What_Are_They_and_How_Do_They_Differ.jpg" alt="TDD vs BDD"></p><h2 id=what-is-tdd>What Is TDD?</h2><p>Test-driven development (TDD) is one of the most popular methodologies today for adding testability to a software project. Test-driven development became popular around 2003 via Kent Beck, alongside the test-first <a href=https://en.wikipedia.org/wiki/Extreme_programming>extreme programming</a>principle. TDD aims to provide 100 percent test coverage in code by working with a very short feedback cycle when writing code. The short feedback cycle drives implementation, verifying functionality with automated testing. In other words, you write tests beforehand and then write functionality so that the software passes those tests.</p><p>The TDD methodology and its short feedback loop are defined in Kent Beck’s book <a href=https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530>Test-Driven Development: By Example</a> with the following steps:</p><ol><li><p>Write a failing test (red).</p></li><li><p>Make the test work ASAP (green).</p></li><li><p>Refactor the code.</p></li></ol><p><img src="https://blog.ncrunch.net/image.axd?picture=2018%2f9%2f___refactor_flow_chart-(1).jpg" alt></p><h3 id=step-1-write-a-failing-test>Step 1: Write a Failing Test</h3><p>The first step with TDD is to create a “red” test that fails. This test doesn’t need to pass, or even compile at all. The primary purpose of this step is to define the functionality to test.</p><h3 id=step-2-make-the-test-pass-asap>Step 2: Make the Test Pass ASAP</h3><p>Once you’ve established a failing test, the next step is to make it pass as quickly as possible. There are no rules in getting the implementation correct to turn the test “green.”</p><h3 id=step-3-refactor-the-code>Step 3: Refactor the Code</h3><p>Once you have a passing test, you have the means to test the functionality created in step two. The next step is to refactor the code to a good standard, such as by removing any duplication created during the previous steps. While refactoring, you’ll have the ability to use the test you just created to ensure that the code is always working as intended.</p><h3 id=tdd-benefits-and-drawbacks>TDD: Benefits and Drawbacks</h3><p>Now that you know the steps involved in test-driven development, let’s look at some of the benefits and drawbacks. Some of the benefits of practicing TDD include:</p><ul><li>Improve code quality by virtue of writing code with testability in mind—this generally results in well-defined and decoupled code that is easy to maintain over time.</li><li>Provide a framework of automated tests that can provide a metric of the code quality at any point. This is great for understanding regression effects when changing functionality in the codebase.</li><li>Test creation alongside functionality creation. Instead of tests being an afterthought, they become as critical as writing functionality.</li></ul><p>Of course, there are some disadvantages as well:</p><ul><li>When considering the business case for writing with testability in mind, it can be difficult to explain how testing can contribute to the bottom line. This is especially difficult for teams working under unrealistic deadlines.</li><li>To follow TDD correctly, you need both the knowledge to actually follow the TDD methodology correctly and the discipline to commit to following the rules of the methodology. Especially as timelines tighten and deadlines loom closer, it becomes easy to push off testing as something to “address later.” </li></ul><p>Now that we’ve covered the basics of TDD, let’s talk about the next testing methodology in our discussion of TDD vs. BDD, behavior-driven development.</p><h2 id=what-is-bdd>What Is BDD?</h2><p>Behavior-driven development (BDD) combines TDD methodology with core principals from <a href=https://en.wikipedia.org/wiki/Object-oriented_programming>object-oriented programming</a> and <a href=https://en.wikipedia.org/wiki/Domain-driven_design>domain-driven development</a>.  BDD allows both technical and non-technical teams to be involved in software development testing efforts. Writing tests in a way that explicitly defines the behavior expected for the software accomplishes this by allowing both non-technical and technical members to be involved in the test definition process.</p><p>Behavior-driven development focuses on creating user stories explaining the desired functionality. This is opposed to test-driven development, which focuses on having a feedback loop driven by written tests. In 2007, Dan North wrote a <a href=https://dannorth.net/whats-in-a-story/>guideline</a> for the different steps of defining a user story—let’s take a look.</p><h3 id=step-1-given>Step 1: Given </h3><p>First, a behavior-driven test will establish the initial context for the test. This step is called “given,” which describes a situation in which functionality will be determined. This step is important in establishing the state of the application before testing for functionality. Since a behavior-driven test should still look to isolate functionality, it’s important to be specific with the context of the user story when determining functionality in the application.</p><h3 id=step-2-when><strong>Step 2: When</strong></h3><p>The next step in writing a BDD test is to establish the “when” criteria. The “when” step describes the action occurring with the “given” content. Generally, this step is a verb describing something happening in a system, such as clicking a page or registering a user.</p><h3 id=step-3-then>Step 3: Then </h3><p>Finally, the last step is to define a “then” statement for the behavior-driven test. This statement describes the final result that occurs after performing an action with the “when” statement.</p><h3 id=bdd-a-quick-example>BDD: A Quick Example</h3><p>Let’s look at an example. If I’m building an application that collects registrations for an event, I’d think about the different functionalities this application can have. A core function to test would be the capability to add an attendee to an already existing event. My “given” statement would look something like: g_iven that an event already exists and is selected._</p><p>Next, I would create a “when” statement to provide an action to perform for this test. Since my goal is to add an attendee to an event, my “when” statement would be: w_hen a user registers for the given event._</p><p>Lastly, I would finish the test by including a “then” statement. Once the user registers for an event, I need to confirm the user was actually registered. My statement could look like: <em>t__hen confirm the user is registered for the event.</em></p><h3 id=bdd-some-of-the-benefits>BDD: Some of the Benefits</h3><p>Let’s go over a few benefits of using behavior-driven development:</p><ul><li>Good user of establishing strong business requirements for the application. Behavior-driven tests provide a framework of tests focusing on the business functionality of the application since they are created with desired behavior in mind.</li><li>High collaboration between domain expert and developers. Building tests in this way helps prevent miscommunication between requirements and implementation.</li><li>Provides repeatable high-level tests for regression throughout the application. If you’ve ever run into a case where business users forget the functionality they’re asking for, this benefit will work really well for you.</li></ul><p>Now that we have a better understanding of behavior-driven testing, let’s look at the differences between TDD vs. BDD.</p><h2 id=tdd-vs-bdd-understanding-the-difference>TDD vs. BDD: Understanding the Difference</h2><p>When looking at the difference between TDD vs. BDD, it’s important to understand that you don’t have to choose just one or the other—you can use TDD and BDD together to cover your organization’s testing needs. By using aspects of both TDD and BDD, you’ll be able to have low-level tests for the details of the codebase, and higher-level tests that touch on the direct functionality desired by the customer. Additionally, the different sectors of your organization can have different involvement in the testing process. A different workflow in test creation can involve different team members, depending on their technical capability.</p><p>First, consider an environment where the development team is driving internal functionality. Test-driven development centers around tests defined by the development team. TDD’s short feedback cycle works well within a development team since the tests created with this methodology tend to be small and quick.</p><p>Second, an environment with more collaboration between the domain experts and development team will benefit from a stronger behavior-driven development process. This allows for tests written in simple English that makes sense for a non-technical user. In addition, behavior-driven tests make for great acceptance tests. These tests define the desired functionality without considering implementation details, allowing them to include non-technical users in creation.</p><h2 id=using-tdd-and-bdd-in-harmony>Using TDD and BDD in Harmony</h2><p>This post should have given you a good understanding of what test-driven development and behavior-driven development are. When considering whether to implement TDD vs. BDD in your workflow, both can create an effective test creation strategy. If you aren’t using one (or both!) of these methodologies, give them each a try and see if they help you with creating better tests for your software.</p><p>]]></p></article></main><footer id=footer></footer></body></html>